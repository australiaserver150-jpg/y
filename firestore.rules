/**
 * @description This ruleset enforces a strict user-ownership model for personal data, while allowing shared access to collaborative content like chats.
 * @dataStructure
 *  - /users/{userId}: Stores user account information, accessible only to the user themselves.
 *  - /user_profiles/{profileId}: Stores user profile information, accessible only to the user themselves.
 *  - /users/{userId}/projects/{projectId}: Stores project data owned by a specific user.
 *  - /chats/{chatId}: Stores chat metadata. Access is controlled by the 'participants' list.
 *  - /chats/{chatId}/messages/{messageId}: Stores individual messages within a chat.
 *  - /statuses/{statusId}: Stores status posts; write access is restricted to the owner.
 *  - /channels/{channelId}: Stores metadata for broadcast channels.
 *  - /channels/{channelId}/messages/{messageId}: Stores messages for a specific channel.
 *  - /users/{userId}/callLogs/{callLogId}: Stores call logs owned by a specific user.
 * @keySecurityDecisions
 *  - User listing is implicitly denied.
 *  - Public read access is not granted to any collection except where explicitly noted.
 *  - The rules default to a strict, owner-only access model where relationships are ambiguous.
 *  - Data consistency between path segments and document fields is enforced on create and update to prevent privilege escalation.
 * @denormalizationForAuthorization
 *  - The `Chat` entity stores a `participants` array containing User IDs to enable efficient authorization checks without requiring additional reads.
 *  - The `Channel` entity stores `ownerId` and `memberIds` for similar authorization purposes.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces that only the authenticated user can read, update, or delete their own user document.
     * @path /users/{userId}
     * @allow (read, write) if request.auth.uid == userId (User A can read/write their own profile)
     * @deny (read, write) if request.auth.uid != userId (User A cannot read/write User B's profile)
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && request.auth.uid == resource.data.id;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Enforces that only the authenticated user can read, update, or delete their own user profile document.
     * @path /user_profiles/{profileId}
     * @allow (read, write) if request.auth.uid == profileId (User A can read/write their own profile)
     * @deny (read, write) if request.auth.uid != profileId (User A cannot read/write User B's profile)
     * @principle Enforces document ownership for all operations.
     */
    match /user_profiles/{profileId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(profileId) {
        return isSignedIn() && request.auth.uid == profileId;
      }
      allow get: if isOwner(profileId);
      allow list: if false;
      allow create: if false;
      allow update: if isOwner(profileId) && request.auth.uid == resource.data.id;
      allow delete: if isOwner(profileId) && resource != null;
    }

    /**
     * @description Enforces that only the owner can read, write, update, or delete their own projects.
     * @path /users/{userId}/projects/{projectId}
     * @allow (create) if request.auth.uid == userId (User A can create a project under their ID)
     * @allow (read, write, delete) if request.auth.uid == userId (User A can read/write/delete their project)
     * @deny (read, write, delete) if request.auth.uid != userId (User A cannot read/write/delete User B's project)
     * @principle Enforces document ownership and data consistency in nested collections.
     */
    match /users/{userId}/projects/{projectId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == request.auth.uid;
      allow update: if isOwner(userId) && request.resource.data.userId == resource.data.userId && resource != null;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Grants access to chat documents based on the presence of the user's ID in the 'participants' array.
     * @path /chats/{chatId}
     * @allow (read, write) if request.auth.uid is in resource.data.participants (User A can read/write the chat if they're a participant)
     * @deny (read, write) if request.auth.uid is not in resource.data.participants (User A cannot read/write the chat if they're not a participant)
     * @principle Implements shared access control based on a participant list.
     */
    match /chats/{chatId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isParticipant() {
        return isSignedIn() && request.auth.uid in resource.data.participants;
      }
      allow get: if isParticipant();
      allow list: if false;
      allow create: if false;
      allow update: if isParticipant() && resource != null;
      allow delete: if false;
    }

    /**
     * @description Grants access to messages within a chat based on the user's participation in the parent chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (read, write) if get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]) (User A can read/write messages if they're a participant in the chat)
     * @deny (read, write) if get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]) is false (User A cannot read/write messages if they're not a participant in the chat)
     * @principle Implements shared access control for subcollection based on parent document's participant list.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isParticipant() {
          return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      }
      allow get: if isParticipant();
      allow list: if isParticipant();
      allow create: if isParticipant();
      allow update: if false;
      allow delete: if false;
    }

   /**
    * @description Allows public read access to statuses but restricts write access to the owner.
    * @path /statuses/{statusId}
    * @allow (read) if true (Anyone can read the status)
    * @allow (create) if request.resource.data.userId == request.auth.uid (User A can create a status if they are the owner)
    * @allow (update, delete) if resource.data.userId == request.auth.uid (User A can update/delete their own status)
    * @deny (create, update, delete) if resource.data.userId != request.auth.uid (User A cannot update/delete User B's status)
    * @principle Implements public read access with owner-only write access for statuses.
    */
    match /statuses/{statusId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isOwner(resource.data.userId) && resource != null;
      allow delete: if isOwner(resource.data.userId) && resource != null;
    }

    /**
     * @description Grants access to channel documents based on the user's role as either the owner or a member.
     * @path /channels/{channelId}
     * @allow (read) if request.auth.uid is in resource.data.memberIds (User A can read the channel if they're a member)
     * @allow (write) if request.auth.uid == resource.data.ownerId (User A can write the channel if they're the owner)
     * @deny (read, write) if request.auth.uid is not in resource.data.memberIds or ownerId (User A cannot read/write the channel if they're not a member or the owner)
     * @principle Implements shared access control based on an owner and a member list.
     */
    match /channels/{channelId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(ownerId) {
        return isSignedIn() && request.auth.uid == ownerId;
      }
      function isMember() {
        return isSignedIn() && request.auth.uid in resource.data.memberIds;
      }
      allow get: if isMember() || isOwner(resource.data.ownerId);
      allow list: if false;
      allow create: if isOwner(resource.data.ownerId);
      allow update: if isOwner(resource.data.ownerId) && resource != null;
      allow delete: if isOwner(resource.data.ownerId) && resource != null;
    }

    /**
     * @description Grants access to messages within a channel based on the user's membership in the parent channel.
     * @path /channels/{channelId}/messages/{messageId}
     * @allow (read, write) if get(/databases/$(database)/documents/channels/$(channelId)).data.memberIds.hasAny([request.auth.uid]) (User A can read/write messages if they're a member in the channel)
     * @deny (read, write) if get(/databases/$(database)/documents/channels/$(channelId)).data.memberIds.hasAny([request.auth.uid]) is false (User A cannot read/write messages if they're not a member in the channel)
     * @principle Implements shared access control for subcollection based on parent document's member list.
     */
    match /channels/{channelId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isMember() {
          return isSignedIn() && get(/databases/$(database)/documents/channels/$(channelId)).data.memberIds.hasAny([request.auth.uid]);
      }
      allow get: if isMember();
      allow list: if isMember();
      allow create: if isMember();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Enforces that only the authenticated user can read, update, or delete their own call logs.
     * @path /users/{userId}/callLogs/{callLogId}
     * @allow (create) if request.auth.uid == userId (User A can create a call log under their ID)
     * @allow (read, write, delete) if request.auth.uid == userId (User A can read/write/delete their call log)
     * @deny (read, write, delete) if request.auth.uid != userId (User A cannot read/write/delete User B's call log)
     * @principle Enforces document ownership and data consistency in nested collections.
     */
    match /users/{userId}/callLogs/{callLogId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && resource != null;
      allow delete: if isOwner(userId) && resource != null;
    }
  }
}