/**
 * @file Firebase Security Rules for ConnectNow application.
 *
 * @description This ruleset enforces a strict user-ownership model for private data and allows public read access to certain collections.
 * Data is organized hierarchically under /users/{userId} for user-specific content.
 *
 * @philosophy Strict user-ownership with public read access where appropriate. Data denormalization is used to avoid complex queries in security rules.
 * @dataStructure
 *   - /users/{userId}: User account information (private, owner-only access).
 *   - /user_profiles/{profileId}: User profile information (public read, owner-only writes).
 *   - /users/{userId}/projects/{projectId}: Projects owned by a specific user (private, owner-only access).
 *   - /chats/{chatId}: Chat metadata, including participants (shared access).
 *   - /chats/{chatId}/messages/{messageId}: Messages within a chat (shared access).
 *   - /statuses/{statusId}: Status posts (public read, owner-only writes).
 *   - /channels/{channelId}: Broadcast channels (public read, owner-only writes).
 *   - /channels/{channelId}/messages/{messageId}: Messages within a channel (shared access).
 *   - /users/{userId}/callLogs/{callLogId}: Call logs for a specific user (private, owner-only access).
 * @keySecurityDecisions
 *   - User listing is disallowed to protect privacy.
 *   - All write operations are protected by authorization checks to prevent unauthorized data modification.
 *   - Public read access is granted to /statuses/ and /channels/ but write access is restricted to the owner.
 *   - The default security posture for ambiguous relationships is strict owner-only access.
 *   - Relational integrity is enforced on create and update operations for ownership fields.
 *
 * @denormalizationForAuthorization
 *   - The `Project` entity contains a `userId` to directly reference the owning user.
 *   - The `Status` entity contains `userName` and `userAvatar` for display purposes.
 *   - The `Chat` entity contains `participants` for easy access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows access to user account information. Only the user themselves can read, write, update, or delete their own data.
     * @path /users/{userId}
     * @allow (create) request.auth.uid == 'user_abc' with request.resource.data.id == 'user_abc'
     * @allow (get, update, delete) request.auth.uid == 'user_abc' if the existing document's id is also 'user_abc'.
     * @deny (create) request.auth.uid != 'user_abc'
     * @deny (get, update, delete) request.auth.uid != 'user_abc'
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data.keys().hasAll(['id']);
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted for privacy reasons

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows read access to all user profiles, but only the profile owner can create, update, or delete their own profile.
     * @path /user_profiles/{profileId}
     * @allow (get, list) any authenticated user can read user profiles
     * @allow (create) request.auth.uid == 'user_abc' with request.resource.data.id == 'profile_abc'
     * @allow (update, delete) request.auth.uid == 'user_abc' if the existing document's id is also 'profile_abc'
     * @deny (create) request.auth.uid != 'user_abc'
     * @deny (update, delete) request.auth.uid != 'user_abc'
     * @principle Public read access with owner-only writes.
     */
    match /user_profiles/{profileId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isOwner(profileId) {
            return isSignedIn() && request.auth.uid == profileId;
        }

        function isExistingOwner(profileId) {
            return isOwner(profileId) && resource.data.keys().hasAll(['id']);
        }

        allow get, list: if true; // All users can read profiles

        allow create: if isOwner(profileId) && request.resource.data.id == profileId;
        allow update: if isExistingOwner(profileId) && request.resource.data.id == resource.data.id;
        allow delete: if isExistingOwner(profileId);
    }

    /**
     * @description Allows access to projects owned by a specific user. Only the owner can read, write, update, or delete their projects.
     * @path /users/{userId}/projects/{projectId}
     * @allow (create) request.auth.uid == 'user_abc' with request.resource.data.userId == 'user_abc'
     * @allow (get, update, delete) request.auth.uid == 'user_abc' if the existing document's userId is also 'user_abc'.
     * @deny (create) request.auth.uid != 'user_abc'
     * @deny (get, update, delete) request.auth.uid != 'user_abc'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/projects/{projectId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data.keys().hasAll(['userId']);
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows access to chat metadata. Any authenticated user who is a participant in the chat can read and write.
     * @path /chats/{chatId}
     * @allow (get, list) request.auth.uid is in the 'participants' array.
     * @allow (create, update, delete) request.auth.uid is in the 'participants' array.
     * @deny (get, list, create, update, delete) request.auth.uid is not in the 'participants' array.
     * @principle Shared access control via participant list.
     */
    match /chats/{chatId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant() {
          return isSignedIn() && resource.data.participants is list && resource.data.participants.hasAny([request.auth.uid]);
      }

      allow get, list: if isParticipant();
      allow create: if isSignedIn() && request.resource.data.participants is list && request.resource.data.participants.hasAny([request.auth.uid]);
      allow update: if isParticipant();
      allow delete: if isParticipant();
    }

    /**
     * @description Allows access to messages within a specific chat. Any authenticated user who is a participant in the chat can read and write messages.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) request.auth.uid is in the parent chat's 'participants' array.
     * @allow (create, update, delete) request.auth.uid is in the parent chat's 'participants' array.
     * @deny (get, list, create, update, delete) request.auth.uid is not in the parent chat's 'participants' array.
     * @principle Shared access control via participant list in the parent chat.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

     function isChatParticipant(chatId) {
          return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants is list && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      }

      allow get, list: if isChatParticipant(chatId);
      allow create: if isChatParticipant(chatId);
      allow update: if isChatParticipant(chatId);
      allow delete: if isChatParticipant(chatId);
    }

     /**
      * @description Allows read access to all statuses, but only the owner can create, update, or delete their own status.
      * @path /statuses/{statusId}
      * @allow (get, list) any authenticated user can read statuses
      * @allow (create) request.auth.uid == 'user_abc' with request.resource.data.userId == 'user_abc'
      * @allow (update, delete) request.auth.uid == 'user_abc' if the existing document's userId is also 'user_abc'.
      * @deny (create) request.auth.uid != 'user_abc'
      * @deny (update, delete) request.auth.uid != 'user_abc'
      * @principle Public read access with owner-only writes.
      */
    match /statuses/{statusId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data.keys().hasAll(['userId']);
      }

      allow get, list: if true; // All users can read statuses

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Allows read access to all channels, but only the owner can create, update, or delete a channel.
     * @path /channels/{channelId}
     * @allow (get, list) any authenticated user can read channels
     * @allow (create) request.auth.uid == 'user_abc' with request.resource.data.ownerId == 'user_abc'
     * @allow (update, delete) request.auth.uid == 'user_abc' if the existing document's ownerId is also 'user_abc'.
     * @deny (create) request.auth.uid != 'user_abc'
     * @deny (update, delete) request.auth.uid != 'user_abc'
     * @principle Public read access with owner-only writes.
     */
    match /channels/{channelId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(ownerId) {
        return isSignedIn() && request.auth.uid == ownerId;
      }

      function isExistingOwner(ownerId) {
        return isOwner(ownerId) && resource.data.keys().hasAll(['ownerId']);
      }

      allow get, list: if true; // All users can read channels

      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Allows access to messages within a specific channel. Any authenticated user who is a member of the channel can read and write messages.
     * @path /channels/{channelId}/messages/{messageId}
     * @allow (get, list) request.auth.uid is in the parent channel's 'memberIds' array.
     * @allow (create, update, delete) request.auth.uid is in the parent channel's 'memberIds' array.
     * @deny (get, list, create, update, delete) request.auth.uid is not in the parent channel's 'memberIds' array.
     * @principle Shared access control via member list in the parent channel.
     */
    match /channels/{channelId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

     function isChannelMember(channelId) {
          return isSignedIn() && get(/databases/$(database)/documents/channels/$(channelId)).data.memberIds is list && get(/databases/$(database)/documents/channels/$(channelId)).data.memberIds.hasAny([request.auth.uid]);
      }

      allow get, list: if isChannelMember(channelId);
      allow create: if isChannelMember(channelId);
      allow update: if isChannelMember(channelId);
      allow delete: if isChannelMember(channelId);
    }

     /**
      * @description Allows access to call logs owned by a specific user. Only the owner can read, write, update, or delete their own call logs.
      * @path /users/{userId}/callLogs/{callLogId}
      * @allow (create) request.auth.uid == 'user_abc'
      * @allow (get, update, delete) request.auth.uid == 'user_abc' if the existing document's userId is also 'user_abc'.
      * @deny (create) request.auth.uid != 'user_abc'
      * @deny (get, update, delete) request.auth.uid != 'user_abc'
      * @principle Enforces document ownership for writes.
      */
      match /users/{userId}/callLogs/{callLogId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isOwner(userId) {
          return isSignedIn() && request.auth.uid == userId;
        }

        function isExistingOwner(userId) {
          return isOwner(userId);
        }

        allow get: if isOwner(userId);
        allow list: if isOwner(userId);

        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }
  }
}