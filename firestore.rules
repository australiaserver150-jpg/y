/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for most data, with some support for shared access in chats and channels. Public read access is granted to the top-level 'statuses' collection.
 *
 * Data Structure:
 * - /users/{userId}: Stores private user account information. Accessible only to the user.
 * - /user_profiles/{profileId}: Stores public user profile information.
 * - /users/{userId}/projects/{projectId}: Stores projects owned by a specific user.
 * - /chats/{chatId}: Stores chat metadata, including participants.
 * - /chats/{chatId}/messages/{messageId}: Stores individual chat messages.
 * - /statuses/{statusId}: Stores status posts. Publicly readable, but only the owner can modify.
 * - /channels/{channelId}: Stores channel metadata, including members.
 * - /channels/{channelId}/messages/{messageId}: Stores individual channel messages.
 * - /users/{userId}/callLogs/{callLogId}: Stores call logs for a specific user. Accessible only to the user.
 *
 * Key Security Decisions:
 * - Strict user ownership is enforced for /users/{userId} and its subcollections.
 * - Public read access is granted to the top-level /statuses collection, but writes are restricted to the owner.
 * - Shared access is implemented for /chats/{chatId} and /channels/{channelId} based on the 'participants' or 'memberIds' fields.
 * - Listing of the /users collection is denied.
 *
 * Denormalization for Authorization:
 * - The 'Project' entity includes a 'userId' field to reference the owning user, reinforcing ownership.
 * - Each document in `chats` contains denormalized participant information for display purposes.
 * - Each document in `statuses` contains denormalized user information (`userName`, `userAvatar`)
 *
 * Structural Segregation:
 * - User data and profiles are separated into distinct collections (/users/{userId} and /user_profiles/{profileId}) to avoid mixing data with different access requirements in the same collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read and write their own user data.
     * @path /users/{userId}
     * @allow (create) request.auth.uid == 'user_abc' with data { id: 'user_abc', ... }
     * @allow (get, update, delete) request.auth.uid == 'user_abc'
     * @deny (create) request.auth.uid != 'user_abc'
     * @deny (get, update, delete) request.auth.uid != 'user_abc'
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted

      allow create: if isSignedIn() && isSelfCreation(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows anyone to read user profiles.
     * @path /user_profiles/{profileId}
     * @allow (get, list) true
     * @deny (create, update, delete) false
     * @principle Public read access with no write access.
     */
    match /user_profiles/{profileId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows users to manage their own projects.
     * @path /users/{userId}/projects/{projectId}
     * @allow (create) request.auth.uid == 'user_abc' with data { userId: 'user_abc', ... }
     * @allow (get, update, delete) request.auth.uid == 'user_abc'
     * @deny (create) request.auth.uid != 'user_abc'
     * @deny (get, update, delete) request.auth.uid != 'user_abc'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/projects/{projectId} {
      allow get, list: if isOwner(userId);

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Allows access to chat metadata for participants.
     * @path /chats/{chatId}
     * @allow (get, list) request.auth.uid in resource.data.participants
     * @allow (create) request.auth.uid in request.resource.data.participants
     * @allow (update, delete) request.auth.uid in resource.data.participants
     * @principle Shared access based on the 'participants' array.
     */
    match /chats/{chatId} {
      allow get, list: if isSignedIn() && hasChatAccess(request.auth.uid, resource.data.participants);

      allow create: if isSignedIn() && hasChatAccess(request.auth.uid, request.resource.data.participants);
      allow update: if isSignedIn() && isExistingChatParticipant(request.auth.uid, resource.data.participants);
      allow delete: if isSignedIn() && isExistingChatParticipant(request.auth.uid, resource.data.participants);
    }

    /**
     * @description Allows access to messages within a chat for participants.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
     * @allow (create) request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
     * @allow (update, delete) false
     * @principle Shared access to messages is based on chat membership.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get, list: if isSignedIn() && isChatParticipant(request.auth.uid, chatId);

      allow create: if isSignedIn() && isChatParticipant(request.auth.uid, chatId);
      allow update, delete: if false;
    }

    /**
     * @description Allows anyone to read statuses, but only the owner can modify them.
     * @path /statuses/{statusId}
     * @allow (get, list) true
     * @allow (create) request.auth.uid == request.resource.data.userId
     * @allow (update, delete) request.auth.uid == resource.data.userId
     * @deny (create) request.auth.uid != request.resource.data.userId
     * @deny (update, delete) request.auth.uid != resource.data.userId
     * @principle Public read access with owner-only writes.
     */
    match /statuses/{statusId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingStatusOwner(request.auth.uid, resource.data.userId);
      allow delete: if isSignedIn() && isExistingStatusOwner(request.auth.uid, resource.data.userId);
    }

    /**
     * @description Allows access to channel metadata for members.
     * @path /channels/{channelId}
     * @allow (get, list) request.auth.uid in resource.data.memberIds
     * @allow (create) request.auth.uid == request.resource.data.ownerId
     * @allow (update, delete) request.auth.uid == resource.data.ownerId
     * @principle Shared access based on the 'memberIds' array, owner can update
     */
    match /channels/{channelId} {
      allow get, list: if isSignedIn() && hasChannelAccess(request.auth.uid, resource.data.memberIds);

      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingChannelOwner(request.auth.uid, resource.data.ownerId);
      allow delete: if isSignedIn() && isExistingChannelOwner(request.auth.uid, resource.data.ownerId);
    }

    /**
     * @description Allows access to messages within a channel for channel members.
     * @path /channels/{channelId}/messages/{messageId}
     * @allow (get, list) request.auth.uid in get(/databases/$(database)/documents/channels/$(channelId)).data.memberIds
     * @allow (create) request.auth.uid in get(/databases/$(database)/documents/channels/$(channelId)).data.memberIds
     * @allow (update, delete) false
     * @principle Shared access to messages is based on channel membership.
     */
    match /channels/{channelId}/messages/{messageId} {
      allow get, list: if isSignedIn() && isChannelMember(request.auth.uid, channelId);

      allow create: if isSignedIn() && isChannelMember(request.auth.uid, channelId);
      allow update, delete: if false;
    }

    /**
     * @description Allows users to read and write their own call logs.
     * @path /users/{userId}/callLogs/{callLogId}
     * @allow (create) request.auth.uid == 'user_abc' with data { id: 'user_abc', ... }
     * @allow (get, update, delete) request.auth.uid == 'user_abc'
     * @deny (create) request.auth.uid != 'user_abc'
     * @deny (get, update, delete) request.auth.uid != 'user_abc'
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/callLogs/{callLogId} {
        allow get, list: if isOwner(userId);

        allow create: if isSignedIn() && isCallLogForUser(request.auth.uid, userId);
        allow update: if isSignedIn() && isExistingCallLogOwner(request.auth.uid, userId);
        allow delete: if isSignedIn() && isExistingCallLogOwner(request.auth.uid, userId);
    }

    // --- Helper Functions ---

    /**
     * @description Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the resource based on the userId.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is creating their own document (e.g., /users/{userId}).
     */
    function isSelfCreation(userId) {
        return isSignedIn() && request.auth.uid == userId && request.resource.data.id == userId;
    }

    /**
     * @description Checks if the user is the owner of the resource and the resource exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user has access to a chat based on the participants array.
     */
    function hasChatAccess(userId, participants) {
      return isSignedIn() && userId in participants;
    }

    /**
     * @description Checks if the user is a participant in the chat and the chat exists.
     */
    function isExistingChatParticipant(userId, participants) {
      return hasChatAccess(userId, participants) && resource != null;
    }

    /**
     * @description Checks if the user is a participant in a chat.
     */
    function isChatParticipant(userId, chatId) {
      return isSignedIn() && userId in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
    }

    /**
     * @description Checks if the user is the owner of the status and the status exists.
     */
    function isExistingStatusOwner(userId, ownerId) {
      return isSignedIn() && userId == ownerId && resource != null;
    }

    /**
     * @description Checks if the user has access to a channel based on the memberIds array.
     */
    function hasChannelAccess(userId, memberIds) {
      return isSignedIn() && userId in memberIds;
    }

    /**
     * @description Checks if the user is the owner of the channel and the channel exists.
     */
    function isExistingChannelOwner(userId, ownerId) {
      return isSignedIn() && userId == ownerId && resource != null;
    }

    /**
     * @description Checks if the user is a member of a channel.
     */
    function isChannelMember(userId, channelId) {
      return isSignedIn() && userId in get(/databases/$(database)/documents/channels/$(channelId)).data.memberIds;
    }

    /**
     * @description Checks if the call log is being created for the authenticated user.
     */
    function isCallLogForUser(userId, expectedUserId) {
        return isSignedIn() && userId == expectedUserId;
    }

    /**
     * @description Checks if the user is the owner of the call log and the call log exists.
     */
    function isExistingCallLogOwner(userId, expectedUserId) {
        return isSignedIn() && userId == expectedUserId && resource != null;
    }
  }
}